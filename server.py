from flask import Flask, request, jsonify
import sys
import os
from pathlib import Path
from flask_cors import CORS
from run import run
import json
import base64
import traceback
from board import Board
import datetime
import uuid
import threading

from server_packets import (
    PCBArtifactRequest, 
    PCBArtifactResponse, 
    RoutingProgressRequest, 
    RoutingProgressResponse, 
    RoutingStartRequest, 
    RoutingStartResponse
)

# Add the parent directory to the Python path if needed
sys.path.append(str(Path(__file__).parent))

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Could be anything really, necessary for reading, the file writtien within the request cycle
file_number = 9999

# The user doesn't need to know about these sorts of errors, enough to throw them and check the logs
def validate_endpoint(data, endpoint):
    if data.get("endpoint") != endpoint:
        raise ValueError(f"Invalid endpoint: {data.get('endpoint')}. Expected: {endpoint}")

def project_to_legacy_json(project_string):
    """ 
    Converts a MakeDevice-new Project JSON string to the legacy format used by the backend.
    """
    # Parse the project data as JSON
    project_json = json.loads(project_string)

    # data_template.json contains lots of fields from the legacy format, we'll use it as a basis for porting
    # over the data from Project  TODO: Move away from the legacy format completely
    data_template_file = Path("./data_template.json")
    data_template = None
    with open(data_template_file, 'r') as template_file:
        data_template = json.load(template_file)

    data_template["board"]["name"] = project_json.get("name")
    data_template["board"]["id"] = project_json.get("id") # New
    data_template["board"]["last_modified"] = project_json.get("lastModified") # New
    data_template["board"]["generation_software"]["version"] = str(project_json.get("projectVersion"))
    data_template["board"]["size"]["x"] = project_json.get("size").get("width")
    data_template["board"]["size"]["y"] = project_json.get("size").get("height")
    data_template["configuration"]["fabrication_options"]["rounded_corner_radius"] = project_json.get("pcbOptions").get("cornerRadius")
    data_template["configuration"]["fabrication_options"]["connectors"]["top"] = project_json.get("pcbOptions").get("connectors").get("top")
    data_template["configuration"]["fabrication_options"]["connectors"]["bottom"] = project_json.get("pcbOptions").get("connectors").get("bottom")

    # HACK: Hardcoded mapping of all mm_* to ec30_* from modules/
    # TODO: Store as mm_* in modules/, shouldn't be called ec30_* in modules/, the footprints aren't even generic
    mm_to_ec30_mapping = {
        "mm_jacdaptor": "ec30_1x7_r6_mh_0.1",
        "mm_keycap_button": "ec30_3x2_lr_mh_0.1",
        "mm_light_sensor": "ec30_2x2_lr_mh_0.1",
        "mm_rgb_ring": "ec30_3x3_l_mh_0.1",
        "mm_rotary_button": "ec30_3x2_lr_mh_0.1"
    }

    # Convert all Project InstanceModules to the legacy format
    for m in project_json.get("modules"):
        instance = {
            "name": m.get("name") + "_" + m.get("version"),
            "position": {
                "x": m.get("position").get("x"),
                "y": -m.get("position").get("y")
            },
            "rotation": (360 - m.get("rotation")) % 360,  # Swap rotation direction
            "id": m.get("id"), # New, but needed for routing feedback
        }
        # Convert mounted modules to ec30_*
        if m.get("name").startswith("mm_"):
            ec30_name = mm_to_ec30_mapping.get(m.get("name"))
            if ec30_name:
                instance["name"] = ec30_name

        data_template["modules"].append(instance)

    return data_template

# TODO: Implement these new endpoints properly
@app.route('/routingStart', methods=['POST'])
def routing_start():
    data: RoutingStartRequest = request.get_json(force=True)
    validate_endpoint(data, "routingStart")

    # Job ID is generated by the backend (to ensure no folder name conflicts)
    job_id = str(uuid.uuid4())

    # Create a temporary working folder named after the job_id
    job_folder = Path(f"./jobs/{job_id}")
    output_folder = job_folder / "output"
    output_folder.mkdir(parents=True, exist_ok=True)
    print(f"ðŸ”µ Created job folder: {job_folder}")
    print(f"ðŸ”µ Created output folder: {output_folder}")

    # Create a file to store the project data
    project_file = output_folder / "project.MakeDevice"
    with open(project_file, 'w') as file:
        file.write(data["project"])
    print(f"ðŸ”µ Project data saved to: {project_file}")

    data = project_to_legacy_json(data["project"])

    # Write the data template to a file
    data_file = job_folder / "data.json"
    with open(data_file, 'w') as file:
        json.dump(data, file, indent=2)

    print(f"ðŸ”µ Project converted to legacy data format, stored at: {data_file}")

    print(f"ðŸ”µ Starting routing with job ID: {job_id}")


    # TODO: Trigger routing in a different thread to allow responding to the client
    # run() or whatever, and create a temp working folder for the job_id
    threading.Thread(target=run, args=("from_server", True, str(job_folder))).start()

    response: RoutingStartResponse = {
        "endpoint": "routingStart",
        "result": {
            "jobId": job_id
        }
    }
    return jsonify(response), 200

# TODO: Implement these new endpoints properly
# 
# A nice to have would be an error if the server crashed since starting the routing, 
# and so the job isn't running anymore. Could just add the jobId to a list when first 
# calling run(), and if the jobId isn't in the list then the server has crashed/restarted 
# since starting the job.
@app.route('/routingProgress', methods=['POST'])
def routing_progress():
    data: RoutingProgressRequest = request.get_json(force=True)
    validate_endpoint(data, "routingProgress")

    job_id = data["jobId"]

    # TODO: Store progress.txt (hack I know) and some routing image(s) in the job folder
    # while routing, and read them here to send back

    response: RoutingProgressResponse = {
        "endpoint": "routingProgress",
        "error": {
            "message": "Routing progress endpoint is not implemented yet.",
            "failedModuleIds": [],
            "succeededModuleIds": []
        }
    }
    return jsonify(response), 200


# TODO: Implement these new endpoints properly
@app.route('/pcbArtifact', methods=['POST'])
def pcb_artifact():
    data: PCBArtifactRequest = request.get_json(force=True)
    validate_endpoint(data, "pcbArtifact")

    job_id = data.get("jobId")
    upload_fab = data.get("uploadToFabHouse", False)

    # TODO: Check if the job_id is valid, and that there's an output.zip file for it
    # HACK: For now, just return output.zip
    if not os.path.exists("./output.zip"):
        response: PCBArtifactResponse = {
            "endpoint": "pcbArtifact",
            "error": {
                "message": "Routing still in progress or not started yet.", # No artifacts found
            }
        }
        return jsonify(response), 200

    # Base64 encode zip
    with open("./output.zip", 'rb') as zip_file:
        zip_data = zip_file.read()
    encoded_zip = base64.b64encode(zip_data).decode('utf-8')

    response: PCBArtifactResponse = {
        "endpoint": "pcbArtifact",
        "result": {
            "zipFile": encoded_zip
        }
    }

    # NOTE: Still use status code 200 for application-level errors, since we want the custom error message
    return jsonify(response), 200

"""

 TODO: Everything below here is old and needs removing, but left as reference for the new implementation

"""

def update_progress(board: Board):
    all = board.sockets.get_socket_count()
    connected = board.connected_sockets_count
    progress = round(float(connected) / float(all), 4) * 100
    print(f"ðŸ”µ Updating progress: {progress}")
    # Write the progress to a file
    with open("./progress.txt", 'w') as file:
        file.write(str(progress))

# @app.route('/download_zip', methods=['POST'])
# def download_zip():
#     pass

@app.route('/progress', methods=['GET'])
def get_progress():
    # If the progress file does not exist
    if os.path.exists("./progress.txt"):
        with open("./progress.txt", 'r') as file:
            progress = file.read()
    else:
        progress = 0
    print(f"ðŸ”µ Getting progress: {progress}")
    millis = datetime.datetime.now().timestamp()
    return jsonify({"progress": progress, "timestamp": millis})


@app.route('/run', methods=['POST'])
def being_routing():
    # Check if the request contains JSON data
    if not request.is_json:
        return jsonify({"error": "Request must be JSON"}), 400
 
    try:
        # Get the data from the request
        data = request.get_json()
        
        # If data is already a dictionary, convert it back to JSON string to save
        if isinstance(data, dict):
            json_str = json.dumps(data)
        else:
            json_str = data
            
        # Save the data to a file
        with open(f"./data/data_{file_number}.json", 'w') as file:
            file.write(json_str)
        

        # Execute the run function with the provided data
        routing_result = run(file_number=file_number, run_from_server=True)

        if routing_result["failed"]:
            # Clear progress
            with open("./progress.txt", 'w') as file:
                file.write(str(0))

            return jsonify({"error": "Routing failed, try repositioning the modules or increased in the board size."}), 500
        
        # Change the result to return the zip file data
        if os.path.exists("./output.zip"):
            with open("./progress.txt", 'w') as file:
                file.write(str(100))

            with open("./output.zip", 'rb') as zip_file:
                zip_data = zip_file.read()
            # Convert binary data to base64 for safe JSON transmission
            encoded_zip = base64.b64encode(zip_data).decode('utf-8')
            result = {"zipData": encoded_zip, "filename": "output.zip"}
            print('sent output.zip')

        else:
            result = {"message": "Processing completed, but no output.zip was generated"}
            print("failed to send output.zip")
        # Return the result
        return jsonify({"success": True, "result": result, "order_urls": routing_result["order_urls"]})
    
    except Exception as e:
        
        error_traceback = traceback.format_exc()
        print("Error: An error occurred while processing the request:")
        print(error_traceback)
        return jsonify({"error": str(e), "traceback": error_traceback}), 500

if __name__ == '__main__':
    # Default to port 5000 or use environment variable if specified
    port = int(os.environ.get("PORT", 3333))

    # Clear progress
    with open("./progress.txt", 'w') as file:
        file.write(str(0))

    # Run the Flask app, enabling debug mode for development
    app.run(host='0.0.0.0', port=port, debug=True)
